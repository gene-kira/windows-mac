"""
Guardian Queen – One-Click PC Sentinel with Setup Wizard

- Single-file Python program (Windows-friendly).
- Auto-installs bleak for Bluetooth LE.
- GUI with:
  - Setup tab (wizard for installing/running Android Agent).
  - Monitor tab (scan, connect, live risk, alerts).
- Connects to Android Guardian Agent over BLE.
- Consumes JSON telemetry, runs anomaly + rule-based scoring.

Android side (required, NOT auto-installed):
- App that:
  - Advertises BLE name containing "guardian_agent".
  - Exposes service UUID: 12345678-1234-5678-1234-56789abcdef0
  - Exposes characteristic UUID: 12345678-1234-5678-1234-56789abcdef1
  - Sends JSON telemetry notifications in the agreed format.
"""

import sys
import subprocess
import threading
import asyncio
import json
from datetime import datetime
from pathlib import Path
from statistics import mean, pstdev

# ============================================================
# Auto-loader: ensure bleak
# ============================================================

def ensure_package(pkg_name: str) -> bool:
    try:
        __import__(pkg_name)
        return True
    except ImportError:
        try:
            print(f"[AUTOLOADER] Installing missing package: {pkg_name} ...")
            subprocess.check_call([sys.executable, "-m", "pip", "install", pkg_name])
            __import__(pkg_name)
            print(f"[AUTOLOADER] Package {pkg_name} installed successfully.")
            return True
        except Exception as e:
            print(f"[AUTOLOADER] Failed to install {pkg_name}: {e}")
            return False

BLE_AVAILABLE = ensure_package("bleak")
if not BLE_AVAILABLE:
    print("ERROR: bleak could not be installed. Bluetooth LE will not work.")
    print("Install manually with: pip install bleak")

from bleak import BleakScanner, BleakClient  # type: ignore

# ============================================================
# BLE service definitions (must match Android agent)
# ============================================================

SERVICE_UUID = "12345678-1234-5678-1234-56789abcdef0"
CHAR_UUID    = "12345678-1234-5678-1234-56789abcdef1"

# ============================================================
# GUI imports (tkinter)
# ============================================================

import tkinter as tk
from tkinter import ttk, messagebox

# ============================================================
# Core: context, logging, engine
# ============================================================

class GuardianContext:
    def __init__(self, base_dir: Path):
        self.base_dir = base_dir
        self.logs_dir = base_dir / "logs"
        self.logs_dir.mkdir(parents=True, exist_ok=True)
        self._log_subscribers = []

    def log(self, level: str, message: str):
        timestamp = datetime.utcnow().isoformat(timespec="seconds") + "Z"
        line = f"[{timestamp}] [{level.upper()}] {message}"
        print(line)

        log_file = self.logs_dir / "guardian.log"
        with log_file.open("a", encoding="utf-8") as f:
            f.write(line + "\n")

        for cb in self._log_subscribers:
            cb(line)

    def subscribe_log(self, callback):
        self._log_subscribers.append(callback)


class GuardianEngine:
    """
    Core queen engine:
    - Maintains known devices.
    - Handles baselines and anomaly scoring.
    - Consumes telemetry snapshots from BLE.
    """

    def __init__(self, base_dir: Path):
        self.context = GuardianContext(base_dir)
        self._devices = []          # list[dict]
        self._baselines = {}        # device_id -> history dict
        self._monitoring = False
        self._current_device_id = None

    # ---------------- Device handling ----------------

    def clear_devices(self):
        self._devices = []

    def add_device(self, dev: dict):
        existing_ids = {d.get("id") for d in self._devices}
        if dev.get("id") not in existing_ids:
            self._devices.append(dev)

    def get_devices(self):
        return list(self._devices)

    # ---------------- Baseline handling ----------------

    def _baseline_path(self, device_id: str) -> Path:
        safe_id = device_id.replace(":", "_").replace("-", "_")
        return self.context.logs_dir / f"baseline_{safe_id}.json"

    def _load_baseline(self, device_id: str):
        if device_id in self._baselines:
            return self._baselines[device_id]
        path = self._baseline_path(device_id)
        if not path.exists():
            self._baselines[device_id] = {"history": []}
            return self._baselines[device_id]
        with path.open("r", encoding="utf-8") as f:
            data = json.load(f)
        self._baselines[device_id] = data
        return data

    def _save_baseline(self, device_id: str, data: dict):
        self._baselines[device_id] = data
        path = self._baseline_path(device_id)
        with path.open("w", encoding="utf-8") as f:
            json.dump(data, f, indent=2)

    def update_baseline(self, device_id: str, snapshot: dict):
        baseline = self._load_baseline(device_id)
        history = baseline.get("history", [])
        history.append(snapshot)
        if len(history) > 200:
            history = history[-200:]
        baseline["history"] = history
        self._save_baseline(device_id, baseline)

    def compute_anomaly_score(self, device_id: str, snapshot: dict) -> tuple[int, str]:
        baseline = self._load_baseline(device_id)
        history = baseline.get("history", [])

        if len(history) < 15:
            explanation = (
                "Baseline not established yet (need ~15+ snapshots).\n"
                "Risk here is based mostly on rules, not history."
            )
            return 50, explanation

        def metric_series(key):
            vals = [h.get(key, None) for h in history if key in h]
            vals = [v for v in vals if isinstance(v, (int, float))]
            return vals if vals else [snapshot.get(key, 0.0)]

        metrics = {
            "idle_upload_kbps": "high",
            "bg_connections": "high",
            "sensor_mismatch_events": "high",
        }

        scores = []
        explanations = []

        for key, direction in metrics.items():
            vals = metric_series(key)
            if not vals:
                continue
            m = mean(vals)
            s = pstdev(vals) or 1.0
            x = snapshot.get(key, m)
            z = (x - m) / s
            if direction == "high":
                anomaly = max(0.0, z)
            else:
                anomaly = max(0.0, -z)

            partial = min(100.0, anomaly * 12.0)
            scores.append(partial)
            explanations.append(
                f"{key}: current={x:.2f}, baseline_mean={m:.2f}, z={z:.2f}, partial={partial:.1f}"
            )

        overall = sum(scores) / len(scores) if scores else 0.0
        explanation_text = "\n".join(explanations) if explanations else "Not enough data for detailed anomaly metrics."

        return int(overall), explanation_text

    # ---------------- Rule-based scoring ----------------

    def known_camera_or_call_apps(self):
        return {
            "com.whatsapp",
            "com.facebook.orca",
            "com.google.android.dialer",
            "com.samsung.android.dialer",
            "com.skype.raider",
            "com.zoom.zmdroid",
            "com.google.android.apps.meetings",
            "com.android.camera",
        }

    def looks_stealthy_service(self, sname: str) -> bool:
        s = sname.lower()
        suspicious_tokens = ["spy", "monitor", "stealth", "secret", "hidden", "remote", "agent"]
        if any(tok in s for tok in suspicious_tokens):
            return True
        if len(s) > 0 and all(c.islower() or c.isdigit() or c in ".:" for c in s):
            if len(s.replace(".", "")) >= 10:
                return True
        return False

    def is_unknown_or_shady_host(self, host: str) -> bool:
        host = host.lower()
        if not host or "." not in host:
            return False
        known_good = [
            "google.com", "gstatic.com", "googleapis.com",
            "facebook.com", "fbcdn.net", "whatsapp.com",
            "microsoft.com", "live.com", "outlook.com",
            "apple.com", "icloud.com",
        ]
        for kg in known_good:
            if host.endswith(kg):
                return False
        shady_tokens = ["vpn", "proxy", "tor", "dark", "hidden", "secure-tunnel"]
        if any(tok in host for tok in shady_tokens):
            return True
        return True

    def score_telemetry_rules(self, snapshot: dict) -> tuple[int, list[str]]:
        flags = []
        score = 0

        fg_app = snapshot.get("fg_app")
        screen_on = snapshot.get("screen_on", True)
        net = snapshot.get("net", {})
        sensors = snapshot.get("sensors", {})
        bg_services = snapshot.get("bg_services", [])

        total_out = net.get("total_bytes_out_last_10s", 0)
        endpoints = [e.get("host", "") for e in net.get("recent_outbound", [])]

        if total_out > 500_000 and not screen_on:
            score += 40
            flags.append("STEALTH_EXFIL")

        suspicious_hits = [h for h in endpoints if self.is_unknown_or_shady_host(h)]
        if suspicious_hits:
            score += 30
            flags.append("UNKNOWN_ENDPOINT_PERSISTENT")

        mic_on = sensors.get("mic_on", False)
        cam_on = sensors.get("cam_on", False)
        if (mic_on or cam_on) and fg_app not in self.known_camera_or_call_apps():
            score += 25
            flags.append("SENSOR_MISMATCH")

        stealth_services = [s for s in bg_services if self.looks_stealthy_service(s)]
        if stealth_services:
            score += 20
            flags.append("STEALTH_SERVICE_RUNNING")

        score = min(100, score)
        return score, flags

    # ---------------- Telemetry handling ----------------

    def handle_telemetry(self, device_id: str, snapshot: dict) -> dict:
        net = snapshot.get("net", {})
        idle_upload_kbps = net.get("total_bytes_out_last_10s", 0) / 10.0 / 1024.0
        bg_connections = len(net.get("recent_outbound", []))
        sensors = snapshot.get("sensors", {})
        sensor_mismatch_events = 1 if (
            (sensors.get("mic_on") or sensors.get("cam_on")) and
            snapshot.get("fg_app") not in self.known_camera_or_call_apps()
        ) else 0

        baseline_snapshot = {
            "idle_upload_kbps": float(idle_upload_kbps),
            "bg_connections": float(bg_connections),
            "sensor_mismatch_events": float(sensor_mismatch_events),
        }
        self.update_baseline(device_id, baseline_snapshot)

        rule_score, flags_rules = self.score_telemetry_rules(snapshot)
        anomaly_score, anomaly_details = self.compute_anomaly_score(device_id, baseline_snapshot)

        overall = int((rule_score * 0.7) + (anomaly_score * 0.3))
        verdict = "CLEAN"
        if overall >= 70 or "STEALTH_EXFIL" in flags_rules or "STEALTH_SERVICE_RUNNING" in flags_rules:
            verdict = "ALERT"
        elif overall >= 40:
            verdict = "WARNING"

        result = {
            "device_id": device_id,
            "time": snapshot.get("t"),
            "rule_score": rule_score,
            "anomaly_score": anomaly_score,
            "overall_score": overall,
            "flags": flags_rules,
            "verdict": verdict,
            "anomaly_details": anomaly_details,
            "snapshot": snapshot,
        }

        self.context.log(
            "info",
            f"Telemetry processed: device={device_id} verdict={verdict} "
            f"overall={overall} rule={rule_score} anomaly={anomaly_score} flags={flags_rules}"
        )

        return result

# ============================================================
# BLE client wrapper (runs in its own thread/loop)
# ============================================================

class BLEMonitor:
    def __init__(self, engine: GuardianEngine, on_result_callback):
        self.engine = engine
        self.on_result_callback = on_result_callback
        self._loop = None
        self._thread = None
        self._stop_event = threading.Event()
        self._client = None

    def start(self, device_address: str):
        if self._thread and self._thread.is_alive():
            return
        self._stop_event.clear()
        self._thread = threading.Thread(
            target=self._run_loop,
            args=(device_address,),
            daemon=True
        )
        self._thread.start()

    def stop(self):
        self._stop_event.set()
        if self._loop:
            asyncio.run_coroutine_threadsafe(self._disconnect(), self._loop)

    def _run_loop(self, device_address: str):
        asyncio.run(self._loop_main(device_address))

    async def _loop_main(self, device_address: str):
        self._loop = asyncio.get_event_loop()
        self.engine.context.log("info", f"BLEMonitor: Connecting to {device_address} ...")

        try:
            async with BleakClient(device_address) as client:
                self._client = client
                self.engine.context.log("info", f"BLEMonitor: Connected to {device_address}")
                await client.start_notify(CHAR_UUID, self._notification_handler)

                while not self._stop_event.is_set():
                    await asyncio.sleep(0.5)

                self.engine.context.log("info", "BLEMonitor: Stop requested.")
                await client.stop_notify(CHAR_UUID)
        except Exception as e:
            self.engine.context.log("error", f"BLEMonitor: error {e}")
        finally:
            self.engine.context.log("info", "BLEMonitor: disconnected")
            self._client = None

    async def _disconnect(self):
        try:
            if self._client and self._client.is_connected:
                await self._client.disconnect()
        except Exception as e:
            self.engine.context.log("error", f"BLEMonitor: disconnect error {e}")

    def _notification_handler(self, handle, data: bytearray):
        try:
            text = data.decode("utf-8", errors="ignore")
            payload = json.loads(text)
        except Exception as e:
            self.engine.context.log("error", f"BLEMonitor: failed to parse notification: {e}")
            return

        if payload.get("type") != "telemetry":
            return

        device_id = payload.get("device_id", "UNKNOWN_DEVICE")
        snapshot = payload.get("snapshot", {})
        result = self.engine.handle_telemetry(device_id, snapshot)
        if self.on_result_callback:
            self.on_result_callback(result)

# ============================================================
# GUI: Tkinter (with Setup + Monitor tabs)
# ============================================================

class GuardianGUI(tk.Tk):
    def __init__(self, engine: GuardianEngine):
        super().__init__()
        self.engine = engine

        self.title("Guardian Queen – One-Click Android BLE Monitor")
        self.geometry("1150x720")

        self.current_device = None
        self.ble_monitor = BLEMonitor(engine, self._on_telemetry_result)

        self._create_widgets()
        self._wire_logging()

    def _create_widgets(self):
        self.columnconfigure(0, weight=1)
        self.rowconfigure(0, weight=1)

        self.tabs = ttk.Notebook(self)
        self.tabs.grid(row=0, column=0, sticky="nsew")

        self.setup_tab = ttk.Frame(self.tabs)
        self.monitor_tab = ttk.Frame(self.tabs)

        self.tabs.add(self.setup_tab, text="Setup")
        self.tabs.add(self.monitor_tab, text="Monitor")

        self._build_setup_tab()
        self._build_monitor_tab()

    # ---------------- Setup tab ----------------

    def _build_setup_tab(self):
        frame = self.setup_tab
        frame.columnconfigure(0, weight=1)
        frame.rowconfigure(2, weight=1)

        title = ttk.Label(frame, text="Setup Wizard – Guardian Agent on Phone", font=("Segoe UI", 14, "bold"))
        title.grid(row=0, column=0, sticky="w", padx=10, pady=(10, 5))

        instructions = (
            "1. On your Android phone, install the Guardian Agent app.\n"
            "   - It must advertise via Bluetooth LE with name containing 'guardian_agent'.\n"
            "   - It must expose service UUID:\n"
            f"       {SERVICE_UUID}\n"
            "     and characteristic UUID:\n"
            f"       {CHAR_UUID}\n"
            "\n"
            "2. Open the app once and grant any required permissions.\n"
            "3. Leave Bluetooth on and the app running in background.\n"
            "4. Then go to the 'Monitor' tab and click 'Scan for BLE Agents', select your phone, and 'Start Monitoring'.\n"
            "\n"
            "This PC program is already wired with anomaly detection and live risk scoring.\n"
            "Once the agent streams telemetry, the queen will continuously watch for spyware-like behavior."
        )
        self.setup_label = tk.Text(frame, wrap="word", height=20)
        self.setup_label.insert("1.0", instructions)
        self.setup_label.configure(state="disabled")
        self.setup_label.grid(row=1, column=0, sticky="nsew", padx=10, pady=(0, 10))

    # ---------------- Monitor tab ----------------

    def _build_monitor_tab(self):
        frame = self.monitor_tab
        frame.columnconfigure(0, weight=1)
        frame.columnconfigure(1, weight=2)
        frame.rowconfigure(0, weight=1)

        left_frame = ttk.Frame(frame, padding=10)
        left_frame.grid(row=0, column=0, sticky="nsew")
        left_frame.columnconfigure(0, weight=1)
        left_frame.rowconfigure(1, weight=1)

        right_frame = ttk.Frame(frame, padding=10)
        right_frame.grid(row=0, column=1, sticky="nsew")
        right_frame.columnconfigure(0, weight=1)
        right_frame.rowconfigure(0, weight=1)
        right_frame.rowconfigure(1, weight=1)
        right_frame.rowconfigure(2, weight=1)

        ttk.Label(left_frame, text="Android Agents (BLE)", font=("Segoe UI", 12, "bold")).grid(
            row=0, column=0, sticky="w", pady=(0, 5)
        )

        self.devices_list = tk.Listbox(left_frame, height=10)
        self.devices_list.grid(row=1, column=0, sticky="nsew")

        btn_frame = ttk.Frame(left_frame)
        btn_frame.grid(row=2, column=0, sticky="ew", pady=10)
        btn_frame.columnconfigure(0, weight=1)
        btn_frame.columnconfigure(1, weight=1)

        self.btn_scan = ttk.Button(btn_frame, text="Scan for BLE Agents", command=self.on_scan_ble)
        self.btn_scan.grid(row=0, column=0, sticky="ew", padx=(0, 5))

        self.btn_monitor = ttk.Button(btn_frame, text="Start Monitoring", command=self.on_toggle_monitoring)
        self.btn_monitor.grid(row=0, column=1, sticky="ew", padx=(5, 0))

        info_text = (
            "This tab is your live control panel.\n"
            "1) Click 'Scan for BLE Agents'.\n"
            "2) Select your phone from the list.\n"
            "3) Click 'Start Monitoring'.\n"
            "The queen will then score all telemetry in real time."
        )
        self.info_label = ttk.Label(left_frame, text=info_text, wraplength=320, foreground="#555")
        self.info_label.grid(row=3, column=0, sticky="ew", pady=(10, 0))

        ttk.Label(right_frame, text="Live Risk & Verdict", font=("Segoe UI", 12, "bold")).grid(
            row=0, column=0, sticky="w"
        )

        risk_frame = ttk.Frame(right_frame)
        risk_frame.grid(row=1, column=0, sticky="ew", pady=(5, 10))
        risk_frame.columnconfigure(0, weight=1)

        self.risk_label = ttk.Label(risk_frame, text="Risk: 0 / 100 (CLEAN)", font=("Segoe UI", 11, "bold"))
        self.risk_label.grid(row=0, column=0, sticky="w", pady=(0, 5))

        self.risk_bar = ttk.Progressbar(risk_frame, orient="horizontal", mode="determinate", maximum=100)
        self.risk_bar.grid(row=1, column=0, sticky="ew")

        ttk.Label(right_frame, text="Recent Alerts / Events", font=("Segoe UI", 12, "bold")).grid(
            row=2, column=0, sticky="w"
        )

        self.alerts_text = tk.Text(right_frame, height=10, wrap="word")
        self.alerts_text.grid(row=3, column=0, sticky="nsew", pady=(5, 10))

        ttk.Label(right_frame, text="Engine Log", font=("Segoe UI", 12, "bold")).grid(
            row=4, column=0, sticky="w"
        )

        self.log_text = tk.Text(right_frame, height=8, wrap="none", bg="#111", fg="#0f0")
        self.log_text.grid(row=5, column=0, sticky="nsew", pady=(5, 0))

        for widget in (self.alerts_text, self.log_text):
            y_scroll = ttk.Scrollbar(widget.master, orient="vertical", command=widget.yview)
            widget.configure(yscrollcommand=y_scroll.set)
            y_scroll.grid(row=widget.grid_info()["row"], column=1, sticky="ns")

    # ---------------- Logging hookup ----------------

    def _wire_logging(self):
        def on_log(line: str):
            self.log_text.after(0, lambda: (self.log_text.insert("end", line + "\n"),
                                            self.log_text.see("end")))
        self.engine.context.subscribe_log(on_log)

    # ---------------- BLE scan ----------------

    def on_scan_ble(self):
        if not BLE_AVAILABLE:
            messagebox.showerror("BLE not available", "bleak is not installed or failed. Cannot scan BLE.")
            return

        self.devices_list.delete(0, "end")
        self.devices_list.insert("end", "Scanning for BLE devices...")

        def worker():
            try:
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)
                devices = loop.run_until_complete(self._scan_ble_devices())
                loop.close()
            except Exception as e:
                self.engine.context.log("error", f"BLE scan error: {e}")
                devices = []

            self.after(0, lambda: self._update_device_list(devices))

        threading.Thread(target=worker, daemon=True).start()

    async def _scan_ble_devices(self):
        self.engine.context.log("info", "Scanning for BLE devices advertising the agent service...")
        devices = await BleakScanner.discover(timeout=6.0)
        agents = []

        for d in devices:
            name = d.name or "Unknown"
            if "guardian_agent" in name.lower() or "android" in name.lower():
                agents.append({
                    "id": d.address,
                    "name": name,
                    "connection": "BLE",
                    "type": "phone",
                })

        self.engine.context.log("info", f"BLE scan finished. Found {len(agents)} candidate device(s).")
        return agents

    def _update_device_list(self, devices):
        self.devices_list.delete(0, "end")
        self.engine.clear_devices()

        if not devices:
            self.devices_list.insert("end", "(No BLE agents found. Is the Android app advertising?)")
            return

        for dev in devices:
            self.engine.add_device(dev)
            label = f"{dev.get('name','Unknown')}  [{dev.get('id','?')}]  ({dev.get('connection','?')})"
            self.devices_list.insert("end", label)
        self.devices_list.select_set(0)
        self.current_device = devices[0]

    # ---------------- Monitoring ----------------

    def on_toggle_monitoring(self):
        if self.engine._monitoring:
            self.engine._monitoring = False
            self.ble_monitor.stop()
            self.btn_monitor.config(text="Start Monitoring")
            self.risk_bar["value"] = 0
            self.risk_label.config(text="Risk: 0 / 100 (CLEAN)")
            return

        idx = self.devices_list.curselection()
        if not idx:
            messagebox.showwarning("No device selected", "Select a device first.")
            return

        devices = self.engine.get_devices()
        if not devices or idx[0] >= len(devices):
            messagebox.showerror("Error", "Selected device invalid.")
            return

        device = devices[idx[0]]
        self.current_device = device
        device_id = device.get("id")

        self.alerts_text.delete("1.0", "end")
        self.risk_bar["value"] = 0
        self.risk_label.config(text="Risk: 0 / 100 (CLEAN)")

        self.engine._monitoring = True

        self.engine.context.log("info", f"Starting BLE monitoring for {device_id}")
        self.ble_monitor.start(device_id)
        self.btn_monitor.config(text="Stop Monitoring")

    def _on_telemetry_result(self, result: dict):
        self.after(0, lambda: self._handle_telemetry_result(result))

    def _handle_telemetry_result(self, result: dict):
        score = result.get("overall_score", 0)
        verdict = result.get("verdict", "CLEAN")
        flags = result.get("flags", [])
        t = result.get("time")

        self.risk_bar["value"] = score
        self.risk_label.config(text=f"Risk: {score} / 100 ({verdict})")

        if verdict in ("WARNING", "ALERT") or flags:
            msg = f"[{t}] Verdict={verdict} Score={score} Flags={', '.join(flags) if flags else 'None'}\n"
            self.alerts_text.insert("end", msg)
            self.alerts_text.see("end")

    def on_closing(self):
        if self.engine._monitoring:
            if not messagebox.askyesno("Exit", "Monitoring is running. Stop and exit?"):
                return
        self.engine._monitoring = False
        self.ble_monitor.stop()
        self.destroy()


# ============================================================
# Entry point
# ============================================================

def main():
    base_dir = Path(__file__).resolve().parent
    engine = GuardianEngine(base_dir)

    app = GuardianGUI(engine)
    app.protocol("WM_DELETE_WINDOW", app.on_closing)
    app.mainloop()

if __name__ == "__main__":
    main()

